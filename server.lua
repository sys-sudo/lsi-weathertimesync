local weatherAPIKey = "Your_API_OpenWeatherMap" -- https://home.openweathermap.org/api_keys
local Locationtime = "Your_LocationTIME" -- https://timezonedb.com/time-zones
local Location = "Your_Location" -- example Bekasi
local weatherAPIURL = "http://api.openweathermap.org/data/2.5/weather?q=" .. Location .. "&appid=" .. weatherAPIKey
local lastConsoleMessage = ""
local lastWeatherFetchTime = 0
local weatherCache = nil
local fetchedTime = nil
local localTime = {hour = 0, minute = 0, second = 0}


local timeAPIs = { "http://timeapi.io/api/Time/current/zone?timeZone=" .. Locationtime, "http://worldtimeapi.org/api/timezone/" .. Locationtime, "https://api-ninjas.com/v1/timezone/" .. Locationtime } local function fetchRealTime() local index = 1 local function tryNextAPI() if index > #timeAPIs then print("\27[31m\27[1m[LSI-LOG]\27[0m Failed to fetch time data from all APIs") return end local apiUrl = timeAPIs[index] index = index + 1 print("\27[33m\27[1m[LSI-LOG]\27[0m Trying API:", apiUrl) PerformHttpRequest(apiUrl, function(statusCode, response, headers) if statusCode == 200 then local data = json.decode(response) local dateTime if apiUrl:find("timeapi.io") then dateTime = data.dateTime elseif apiUrl:find("worldtimeapi.org") then dateTime = data.datetime elseif apiUrl:find("api-ninjas.com") then dateTime = data.datetime end if dateTime then fetchedTime = dateTime local hour, minute, second = dateTime:match("(%d+):(%d+):(%d+)") localTime.hour = tonumber(hour) localTime.minute = tonumber(minute) localTime.second = tonumber(second) print("\27[32m\27[1m[LSI-LOG]\27[0m Time data fetched successfully from:", apiUrl) TriggerClientEvent("updateRealTime", -1, localTime.hour, localTime.minute, localTime.second) else print("\27[31m\27[1m[LSI-LOG]\27[0m Failed to parse time data from:", apiUrl) tryNextAPI() end else print("\27[31m\27[1m[LSI-LOG]\27[0m Failed to fetch time data from:", apiUrl) tryNextAPI() end end, "GET", "", { ["Content-Type"] = "application/json" }) end tryNextAPI() end local function getLocalTime() if not fetchedTime then fetchRealTime() else local currentTime = os.date("*t") if currentTime.hour ~= localTime.hour or currentTime.min ~= localTime.minute then fetchRealTime() end TriggerClientEvent("updateRealTime", -1, localTime.hour, localTime.minute, localTime.second) end end function fetchWeather() local currentTime = os.time() if currentTime - lastWeatherFetchTime < 300 then if weatherCache then TriggerClientEvent("updateWeather", -1, weatherCache.weather) print(lastConsoleMessage) return end end PerformHttpRequest(weatherAPIURL, function(statusCode, response, headers) if statusCode == 200 then local data = json.decode(response) local weather = data.weather[1].main local consoleMessage = "\27[32m\27[1m[LSI-LOG]\27[0m Current weather in " .. Location .. ": " .. weather lastConsoleMessage = consoleMessage weatherCache = {weather = weather} lastWeatherFetchTime = os.time() print(consoleMessage) TriggerClientEvent("updateWeather", -1, weather) else local consoleMessage = "\27[31m\27[1m[LSI-LOG]\27[0m Failed to fetch weather data from OpenWeatherMap: " .. statusCode lastConsoleMessage = consoleMessage print(consoleMessage) end end, "GET", "", { ["Content-Type"] = "application/json" }) end AddEventHandler("onResourceStart", function(resourceName) if (GetCurrentResourceName() == resourceName) then print("LSI-weathertimesync is started, script by ReactZIP") local hasQBWeatherSync = GetResourceState("qb-weathersync") == "started" local hasQBcore = GetResourceState("qbcore") == "started" if hasQBWeatherSync then StopResource("qb-weathersync") print("qb-weathersync has been stopped due to conflict") else print("Good, now lsi-weathertimesync is RUNNING") end TriggerEvent("qb-weathersync:client:ToggleWeather", false) end end) Citizen.CreateThread(function() while true do fetchWeather() Citizen.Wait(55555) end end) Citizen.CreateThread(function() while true do getLocalTime() Citizen.Wait(1111) end end)
